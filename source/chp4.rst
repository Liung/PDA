.. _chp4index:

===================================================
NumPy Basics: Arrays and Vectorized Computation
===================================================

NumPy 是 Numerical Python 的简称，是高性能计算和数据分析的基础包。本书中几乎所有高级工具都是建立在它的基础之上，下面是它所能做的一些事情：

 - ndarray，快速和节省空间的多维数组，提供数组化的算数运算和高级的 *广播* 功能。
 - 使用标准数学函数对整个数组的数据进行快速运算，而不需要编写循环。
 - 读取/写入磁盘上的阵列数据和操作存储器映像文件的工具。
 - 线性代数，随机数生成，和傅里叶变换的能力。
 - 集成C，C++，Fortran代码的工具。

从生态系统的角度看，最后一点是最为重要的。因为NumPy 提供了易用的C API，它可以很容易的将数据传递到使用低级语言编写的外部库，也可以使外部库返回NumPy数组数据到Python。
这一特性使得Python成为包装传统的C/C++/Fortran代码库，并给它们一个动态的、易于使用的接口的首选语言。


虽然NumPy本身并没有提供非常高级的数据分析功能，但是了解NumPy的数组和面向数组的计算将会帮助你高效的使用类似于pandas这样的工具。
如果你是Python新手，并且只希望使用pandas来处理你手边的数据，随时可以略过这一章。
更多的NumPy的特性例如广播，请见 :ref:`第12章 <chp12index>` 。

对于大多数的数据分析应用来说，我关注的主要功能是： 
 
 - 快速的向量化数组操作：数据切割和清除，子集和过滤，转化和任何其它类型的计算
 - 通用的数组算法，例如：sorting，unique和set操作
 - 有效的描述性统计和聚集/汇总数据
 - 数据对齐、关系数据的合并操作、异构数据的拼接操作
 - 使用数组表达式来表示条件逻辑，而不是用带有 `if-elif-else` 分支的循环来表示
 - 组间数据的操作（聚合，转换，功能应用）。关于这一点详见 :ref:`第5章 <chp5index>` 



 
虽然NumPy提供了这些操作的计算功能，但你或许希望使用pandas作为大多数数据分析的基础（特别是结构化或表格数据），因为它提供了一个丰富的，高级的接口使得常见的数据任务非常简洁和简单。
pandas也提供了更多的一些特定领域的功能，如时间数组操作，这是NumPy所没有的。

 
 .. image:: _static/pda1.png
   :width: 100
   :height: 100

 在本章和全书，我始终使用 **import numpy as np** 。当然，你喜欢在代码中使用 **from numpy import \*** 来避免写 **np** ，但我要提醒你反对这种习惯。


NumPy ndarray：多维数组对象
==================================


NumPy的一个关键特性是它的N维数组对象(ndarray)，它在Python中是一个大型数据集的快速的，灵活的容器。
数组使你能够在整个数据块上进行数学运算，且与对应的标量元素间操作有相似的语法： ::

  In [8]: data
  Out[8]:
  array([[ 0.9526, -0.246 , -0.8856],
         [ 0.5639, 0.2379, 0.9104]])
  In [9]: data * 10                           In [10]: data + data
  Out[9]:                                     Out[10]:
  array([[ 9.5256, -2.4601, -8.8565],         array([[ 1.9051, -0.492 , -1.7713],
         [ 5.6385, 2.3794, 9.104 ]])                 [ 1.1277, 0.4759, 1.8208]])
     

ndarray是一个同种类数据的多维容器，也就是说，它的所有元素都是同类型的。每一个数组都有一个 **shape** （表示它每一维大小的元组）和 **dtype** （一个描述数组数据类型的对象）： ::

  In [11]: data.shape
  Out[11]: (2, 3)
  In [12]: data.dtype
  Out[12]: dtype('float64')

本章将介绍ndarray的基础知识，并足以应对本书剩下的部分。
虽然对于许多的数据分析应用来说不必要对NumPy有深入的理解，但是精通面向数组编程和思想是成为一名科学的Python大师的关键一步。

 .. image:: /_static/pda1.png
   :width: 100
   :height: 100

 每当你在正文中看见“array”, “NumPy array”, or “ndarray”，除了很少的列外之外，它们都指的是同一个东西：ndarray对象。 


创建ndarray
=====================

最简单的创建数组的方式是使用 **array** 函数。它接受任何数组对象（包括其它数组），产生一个包含所传递的数据的新NumPy数组。例如，列表就是一个很好的用于转换的候选： ::

  In [13]: data1 = [6, 7.5, 8, 0, 1]
  In [14]: arr1 = np.array(data1)
  In [15]: arr1
  Out[15]: array([ 6. , 7.5, 8. , 0. , 1. ])

嵌套序列，如等长列表的列表，将会转化为一个多维数组： ::

  In [16]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
  In [17]: arr2 = np.array(data2)
  In [18]: arr2
  Out[18]:
  array([[1, 2, 3, 4],
  [5, 6, 7, 8]])
  In [19]: arr2.ndim
  Out[19]: 2
  In [20]: arr2.shape
  Out[20]: (2, 4)

除非明确指定（在此以后会更多）， **np.array** 试图推断一个好的数据类型给它所创建的数组。数据类型存储在一个特定的 **dtype** 的对象中；例如，在上面的两个例子中，我们有： ::

  In [21]: arr1.dtype
  Out[21]: dtype('float64')
  In [22]: arr2.dtype
  Out[22]: dtype('int64')

除 **np.array** 之外，还有许多函数来创建新的数组。例如， **zeros** 和 **ones** 使用给定的长度或形状分别的创建0\ :sup:`'`\ s 和 1\ :sup:`'`\ s数组。 **empty** 会创建一个没有使用特定值来初始化的数组。给这些方法传递一个元组作为形状来创建高维数组： ::

  In [23]: np.zeros(10)
  Out[23]: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
  In [24]: np.zeros((3, 6))
  Out[24]:
  array([[ 0., 0., 0., 0., 0., 0.],
         [ 0., 0., 0., 0., 0., 0.],
         [ 0., 0., 0., 0., 0., 0.]])
  In [25]: np.empty((2, 3, 2))
  Out[25]:
  array([[[ 4.94065646e-324, 4.94065646e-324],
          [ 3.87491056e-297, 2.46845796e-130],
          [ 4.94065646e-324, 4.94065646e-324]],
         [[ 1.90723115e+083, 5.73293533e-053],
          [ -2.33568637e+124, -6.70608105e-012],
          [ 4.42786966e+160, 1.27100354e+025]]])

  .. image:: /_static/pda2.png
     :width: 100
     :height: 100

  假定 **np.array** 会返回一个全零的数组是不安全的。在许多情况下，如前所示，它将返回未初始化的垃圾值。

**arange** 是Python内建 **range** 函数的数组版本：

  .. code:: python

     In [26]: np.arange(15)
     Out[26]: array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])

表格 :ref:`Table4-1` 是一个用于构建数组的标准函数的清单。

.. _Table4-1:

Table 4-1. adjflafd

+------------+------------+
| 函数       | 描述       |
+============+============+
| body row 1 | column 2   |
+------------+------------+
| body row 2 | Cells      |
+------------+------------+
| body row 3 | Cells may  |
+------------+ span rows. |
| body row 4 |            |
+------------+------------+

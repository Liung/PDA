.. _chp4index:

===================================================
NumPy Basics: Arrays and Vectorized Computation
===================================================

NumPy 是 Numerical Python 的简称，是高性能计算和数据分析的基础包。本书中几乎所有高级工具都是建立在它的基础之上，下面是它所能做的一些事情：

 - ndarray，快速和节省空间的多维数组，提供数组化的算数运算和高级的 *广播* 功能。
 - 使用标准数学函数对整个数组的数据进行快速运算，而不需要编写循环。
 - 读取/写入磁盘上的阵列数据和操作存储器映像文件的工具。
 - 线性代数，随机数生成，和傅里叶变换的能力。
 - 集成C，C++，Fortran代码的工具。

从生态系统的角度看，最后一点是最为重要的。因为NumPy 提供了易用的C API，它可以很容易的将数据传递到使用低级语言编写的外部库，也可以使外部库返回NumPy数组数据到Python。
这一特性使得Python成为包装传统的C/C++/Fortran代码库，并给它们一个动态的、易于使用的接口的首选语言。


虽然NumPy本身并没有提供非常高级的数据分析功能，但是了解NumPy的数组和面向数组的计算将会帮助你高效的使用类似于pandas这样的工具。
如果你是Python新手，并且只希望使用pandas来处理你手边的数据，随时可以略过这一章。
更多的NumPy的特性例如广播，请见 :ref:`第12章 <chp12index>` 。

对于大多数的数据分析应用来说，我关注的主要功能是： 
 
 - 快速的向量化数组操作：数据切割和清除，子集和过滤，转化和任何其它类型的计算
 - 通用的数组算法，例如：sorting，unique和set操作
 - 有效的描述性统计和聚集/汇总数据
 - 数据对齐、关系数据的合并操作、异构数据的拼接操作
 - 使用数组表达式来表示条件逻辑，而不是用带有 `if-elif-else` 分支的循环来表示
 - 组间数据的操作（聚合，转换，功能应用）。关于这一点详见 :ref:`第5章 <chp5index>` 



 
虽然NumPy提供了这些操作的计算功能，但你或许希望使用pandas作为大多数数据分析的基础（特别是结构化或表格数据），因为它提供了一个丰富的，高级的接口使得常见的数据任务非常简洁和简单。
pandas也提供了更多的一些特定领域的功能，如时间数组操作，这是NumPy所没有的。

 
 .. image:: _static/pda1.png
   :width: 100
   :height: 100

 在本章和全书，我始终使用 **import numpy as np** 。当然，你喜欢在代码中使用 **from numpy import \*** 来避免写 **np** ，但我要提醒你反对这种习惯。


NumPy ndarray：多维数组对象
==================================


NumPy的一个关键特性是它的N维数组对象(ndarray)，它在Python中是一个大型数据集的快速的，灵活的容器。
数组使你能够在整个数据块上进行数学运算，且与对应的标量元素间操作有相似的语法： ::

  In [8]: data
  Out[8]:
  array([[ 0.9526, -0.246 , -0.8856],
         [ 0.5639, 0.2379, 0.9104]])
  In [9]: data * 10                           In [10]: data + data
  Out[9]:                                     Out[10]:
  array([[ 9.5256, -2.4601, -8.8565],         array([[ 1.9051, -0.492 , -1.7713],
         [ 5.6385, 2.3794, 9.104 ]])                 [ 1.1277, 0.4759, 1.8208]])
     

ndarray是一个同种类数据的多维容器，也就是说，它的所有元素都是同类型的。每一个数组都有一个 **shape** （表示它每一维大小的元组）和 **dtype** （一个描述数组数据类型的对象）： ::

  In [11]: data.shape
  Out[11]: (2, 3)
  In [12]: data.dtype
  Out[12]: dtype('float64')

本章将介绍ndarray的基础知识，并足以应对本书剩下的部分。
虽然对于许多的数据分析应用来说不必要对NumPy有深入的理解，但是精通面向数组编程和思想是成为一名科学的Python大师的关键一步。

 .. image:: /_static/pda1.png
   :width: 100
   :height: 100

 每当你在正文中看见“array”, “NumPy array”, or “ndarray”，除了很少的列外之外，它们都指的是同一个东西：ndarray对象。 


创建ndarray
=====================

最简单的创建数组的方式是使用 **array** 函数。它接受任何数组对象（包括其它数组），产生一个包含所传递的数据的新NumPy数组。例如，列表就是一个很好的用于转换的候选： ::

  In [13]: data1 = [6, 7.5, 8, 0, 1]
  In [14]: arr1 = np.array(data1)
  In [15]: arr1
  Out[15]: array([ 6. , 7.5, 8. , 0. , 1. ])

嵌套序列，如等长列表的列表，将会转化为一个多维数组： ::

  In [16]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
  In [17]: arr2 = np.array(data2)
  In [18]: arr2
  Out[18]:
  array([[1, 2, 3, 4],
  [5, 6, 7, 8]])
  In [19]: arr2.ndim
  Out[19]: 2
  In [20]: arr2.shape
  Out[20]: (2, 4)

除非明确指定（在此以后会更多）， **np.array** 试图推断一个好的数据类型给它所创建的数组。数据类型存储在一个特定的 **dtype** 的对象中；例如，在上面的两个例子中，我们有： ::

  In [21]: arr1.dtype
  Out[21]: dtype('float64')
  In [22]: arr2.dtype
  Out[22]: dtype('int64')

除 **np.array** 之外，还有许多函数来创建新的数组。例如， **zeros** 和 **ones** 使用给定的长度或形状分别的创建0\ :sup:`'`\ s 和 1\ :sup:`'`\ s数组。 **empty** 会创建一个没有使用特定值来初始化的数组。给这些方法传递一个元组作为形状来创建高维数组： ::

  In [23]: np.zeros(10)
  Out[23]: array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
  In [24]: np.zeros((3, 6))
  Out[24]:
  array([[ 0., 0., 0., 0., 0., 0.],
         [ 0., 0., 0., 0., 0., 0.],
         [ 0., 0., 0., 0., 0., 0.]])
  In [25]: np.empty((2, 3, 2))
  Out[25]:
  array([[[ 4.94065646e-324, 4.94065646e-324],
          [ 3.87491056e-297, 2.46845796e-130],
          [ 4.94065646e-324, 4.94065646e-324]],
         [[ 1.90723115e+083, 5.73293533e-053],
          [ -2.33568637e+124, -6.70608105e-012],
          [ 4.42786966e+160, 1.27100354e+025]]])

\

 .. image:: /_static/pda2.png
    :width: 100
    :height: 100
 
 假定 **np.array** 会返回一个全零的数组是不安全的。在许多情况下，如前所示，它将返回未初始化的垃圾值。

**arange** 是Python内建 **range** 函数的数组版本： ::

       In [26]: np.arange(15)
       Out[26]: array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
    

`表格4-1`_ 是一个用于构建数组的标准函数的清单。


\

.. _表格4-1:


*表格4-1 数组构建函数*

+-------------------+------------------------------------------+
| 函数              | 描述                                     |
+===================+==========================================+
| array             | 转换输入数据（列表，数组或其它序列类型） |
|                   | 到一个ndarray，可以推断一个dtype或明确的 |
|                   | 设置一个dtype。默认拷贝输入数据。        |
+-------------------+------------------------------------------+
| asarray           | 转换输入为一个ndarray，当输入已经是一个  |
|                   | ndarray时就不拷贝。                      |
+-------------------+------------------------------------------+
|  arange           | 同内建的range函数，但不返回列表而是一个  |
|                   | ndarray                                  |
+-------------------+------------------------------------------+
| ones, ones_like   | 根据提供的shape和dtype产生一个全1的数组。|
|                   | ones_like使用另一歌数组为入参，产生一个  |
|                   | shape和dtype都相同的数组。               |
+-------------------+------------------------------------------+
| zeros, zeros_like | 同ones和ones_like，但是生成全0的数组     |
+-------------------+------------------------------------------+
| empty, enpty_like | 通过分配新内存来构造新的数组，但不同与   |
|                   | ones 和 zeros，不初始任何值。            |
+-------------------+------------------------------------------+
| eye, identity     | 生成一个NxN的单位方阵（对角线上为1，其它 |
|                   | 地方为0）                                |
+-------------------+------------------------------------------+


ndarray的数据类型
=========================

数据类型或dtype是一个特别的对象，保存了ndarray如何解释一块内存为特定类型数据的信息： ::

    In [27]: arr1 = np.array([1, 2, 3], dtype=np.float64)
    In [28]: arr2 = np.array([1, 2, 3], dtype=np.int32)
    In [29]: arr1.dtype
    Out[29]: dtype('float64')
    In [30]: arr2.dtype
    Out[30]: dtype('int32')

Dtypes是使NumPy如此强大和灵活的一部分。在大多数情况下，它们直接映射到底层的机器表示，这是的很容易地读取和写入二进制流到磁盘上，也能链接低级语言，如C
或Fortran编写的代码。数值表示的dtypes以相同的方式命名：一个类型名，如 ``folt`` 或 ``int`` ，后面跟着一个表示数字有多少位的数字。一个标准的双精度浮点值（它是Python的 ``float`` 对象的底层表示）占据8字节或64位。因此，这一类型在NumPy中被认为是 ``float64`` 。见 `表格4-2`_ 是一个NumPy支持的全部数据类型的清单。

    .. image: _static/pad1.png
       :width: 100
       :height: 100

    不要为了记忆NumPy的dtypes而烦恼，尤其你是一个新用户。通常只需要关心你所处理数据的普通类型（浮点、复数、整形、布尔型、字符窜或一般的Python对象）。当你需要更多的控制数据如何存储到内存和磁盘，特别是大的数据集，知道你所控制的存储类型是很好的。
 

.. _表格4-2:

\

表格4-2 NumPy 数据类型


+------------------+---------+-------------------------------------------+
| 类型             | 类型码  | 描述                                      |
+==================+=========+===========================================+
| int8, uint8      | i1, u1  | 有符号和无符号8位（1字节）整数类型        |
+------------------+---------+-------------------------------------------+
| int16, uint16    | i2, u2  | 有符号和无符号16位整数类型                |
+------------------+---------+-------------------------------------------+
| int32, uint32    | i4, u4  | 有符号和无符号32位整数类型                |
+------------------+---------+-------------------------------------------+
| int64, uint64    | i8, u8  | 有符号和无符号64位整数类型                |
+------------------+---------+-------------------------------------------+
| float16          | f2      | 半精度浮点类型                            |
+------------------+---------+-------------------------------------------+
| float32          | f4 or f | 标准精度浮点。与C的 ``float`` 兼容        |
+------------------+---------+-------------------------------------------+
| float64, float128| f8 or d | 标准双精度浮点。与C的 ``double`` 和       |
|                  |         | Python 的 ``folat`` 对象兼容              |
+------------------+---------+-------------------------------------------+
| float128         | f16 or g|  扩展精度浮点                             |
+------------------+---------+-------------------------------------------+
| complex64,       | c8, c16,| 分别使用两个32，64，128位浮点表示的复数   |
| complex128,      | c32     |                                           |
| complex256       |         |                                           |
+------------------+---------+-------------------------------------------+
| bool             | ?       |  布尔值，存储 ``True`` 和 ``False``       |
+------------------+---------+-------------------------------------------+
| object           | O       |  Python对象类型                           |
+------------------+---------+-------------------------------------------+
| string\_         | S       |  定长字符窜类型（每字符一字节）。例如，   |
|                  |         |  为了生成长度为10的字符窜，使用 'S10'     |
+------------------+---------+-------------------------------------------+
| unicode\_        | f16 or g|  扩展精度浮点（字节书依赖平台）。         |
|                  |         |  同 ``string_`` 有相同的语义规范（例如：  |
|                  |         |  ``U10`` ）                               |
+------------------+---------+-------------------------------------------+


你可以使用ndarray的 **astype** 方法显示的把一个数组的dtype转换或 ``投射`` 到另外的类型： ::
  
  In [31]: arr = np.array([1, 2, 3, 4, 5])
  In [32]: arr.dtype
  Out[32]: dtype('int64')
  In [33]: float_arr = arr.astype(np.float64)
  In [34]: float_arr.dtype
  Out[34]: dtype('float64')


在这个例子中，整形被转换到浮点型。如果把浮点数转换到整形dtype，小数部分将会被截断： ::

  In [35]: arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
  In [36]: arr
  Out[36]: array([ 3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
  In [37]: arr.astype(np.int32)
  Out[37]: array([ 3, -1, -2, 0, 12, 10], dtype=int32)

你可能有一个字符窜数组表示的数字，可以使用 **astype** 把它们转换到数字的形式： ::

  In [38]: numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
  In [39]: numeric_strings.astype(float)
  Out[39]: array([ 1.25, -9.6 , 42. ])


如果因为某些原因（如一个字符窜不能转换到 **float64** ）转换失败了，将会引起一个 **TypeError** 。正如你所看见的，我有一些懒，使用 **float** 而不是 **np.float64** ；NumPy会足够聪明的把Python的类型对应到等价的dtypes。

你也可以使用dtype的另一个属性： ::

  In [40]: int_array = np.arange(10)
  In [41]: calibers = np.array([.22, .270, .357, .380, .44, .50], dtype=np.float64)
  In [42]: int_array.astype(calibers.dtype)
  Out[42]: array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

你也可以使用速记的类型码字符窜来指定一个dtype： ::

       In [43]: empty_uint32 = np.empty(8, dtype='u4')
       In [44]: empty_uint32
       Out[44]:
       array([ 0, 0, 65904672, 0, 64856792, 0,
               39438163, 0], dtype=uint32)

\

  .. image:: _static/pda1.png
     :width: 100
     :height: 100

  调用 **astype** 总是会创建一个新的数组（原数据的拷贝），即使是新的dtype和原来的dtype相同。

\

  .. image:: _static/pda2.png
     :width: 100
     :height: 100

  值得牢记的是浮点数，如那些是 **float64** 和 **float32** 的数组，是唯一能够接近分数的。在复杂的计算中，可能会产生 *浮点错误* ，计较时到了一定的小数位数时才有效。


数组和标量间的操作
======================

数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。
这通常被叫做向量化。相同大小的数组间的算数运算，其操作作用在对应的元素上： ::

  
  In [45]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])
  
  In [46]: arr
  Out[46]: 
  array([[ 1.,  2.,  3.],
         [ 4.,  5.,  6.]])
  
  In [47]: arr * arr                 In [48]:arr - arr
  Out[47]:                           Out[48]:
  array([[  1.,   4.,   9.],        array([[ 0., 0., 0.],
         [ 16.,  25.,  36.]])              [ 0., 0., 0.]])

 
标量的算数操作正如你期望的一样，把操作值作用于每一个元素： ::

  P85


在不同大小的数组见的操作被叫做 ``broadcasting`` ，将在 :ref:`第12章 <chp12index>` 详细讨论。深入的了解broadcasting在本书的多数地方是不必要的。


基本的索引和切片
===================

NumPy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于Python的列表： ::

  In [51]: arr = np.arange(10)
  In [52]: arr
  Out[52]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  In [53]: arr[5]
  Out[53]: 5
  In [54]: arr[5:8]
  Out[54]: array([5, 6, 7])
  In [55]: arr[5:8] = 12
  In [56]: arr
  Out[56]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  
如你所见，当你给一个切片赋一标量值，如 ``arr[5:8] = 12`` 所示，该值被传送（或 *传播* ）到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组： ::

  P86
   
